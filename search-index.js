var searchIndex = JSON.parse('{\
"byteorder":{"doc":"This crate provides convenience methods for encoding and …","i":[[8,"ByteOrder","byteorder","<code>ByteOrder</code> describes types that can serialize integers as …",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from <code>buf</code>.",0,[[],["u16",15]]],[11,"read_u24","","Reads an unsigned 24 bit integer from <code>buf</code>, stored in u32.",0,[[],["u32",15]]],[10,"read_u32","","Reads an unsigned 32 bit integer from <code>buf</code>.",0,[[],["u32",15]]],[11,"read_u48","","Reads an unsigned 48 bit integer from <code>buf</code>, stored in u64.",0,[[],["u64",15]]],[10,"read_u64","","Reads an unsigned 64 bit integer from <code>buf</code>.",0,[[],["u64",15]]],[10,"read_u128","","Reads an unsigned 128 bit integer from <code>buf</code>.",0,[[],["u128",15]]],[10,"read_uint","","Reads an unsigned n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["u64",15]]],[10,"read_uint128","","Reads an unsigned n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["u128",15]]],[10,"write_u16","","Writes an unsigned 16 bit integer <code>n</code> to <code>buf</code>.",0,[[["u16",15]]]],[11,"write_u24","","Writes an unsigned 24 bit integer <code>n</code> to <code>buf</code>, stored in u32.",0,[[["u32",15]]]],[10,"write_u32","","Writes an unsigned 32 bit integer <code>n</code> to <code>buf</code>.",0,[[["u32",15]]]],[11,"write_u48","","Writes an unsigned 48 bit integer <code>n</code> to <code>buf</code>, stored in u64.",0,[[["u64",15]]]],[10,"write_u64","","Writes an unsigned 64 bit integer <code>n</code> to <code>buf</code>.",0,[[["u64",15]]]],[10,"write_u128","","Writes an unsigned 128 bit integer <code>n</code> to <code>buf</code>.",0,[[["u128",15]]]],[10,"write_uint","","Writes an unsigned integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["usize",15],["u64",15]]]],[10,"write_uint128","","Writes an unsigned integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["usize",15],["u128",15]]]],[11,"read_i16","","Reads a signed 16 bit integer from <code>buf</code>.",0,[[],["i16",15]]],[11,"read_i24","","Reads a signed 24 bit integer from <code>buf</code>, stored in i32.",0,[[],["i32",15]]],[11,"read_i32","","Reads a signed 32 bit integer from <code>buf</code>.",0,[[],["i32",15]]],[11,"read_i48","","Reads a signed 48 bit integer from <code>buf</code>, stored in i64.",0,[[],["i64",15]]],[11,"read_i64","","Reads a signed 64 bit integer from <code>buf</code>.",0,[[],["i64",15]]],[11,"read_i128","","Reads a signed 128 bit integer from <code>buf</code>.",0,[[],["i128",15]]],[11,"read_int","","Reads a signed n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["i64",15]]],[11,"read_int128","","Reads a signed n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["i128",15]]],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point …",0,[[],["f32",15]]],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point …",0,[[],["f64",15]]],[11,"write_i16","","Writes a signed 16 bit integer <code>n</code> to <code>buf</code>.",0,[[["i16",15]]]],[11,"write_i24","","Writes a signed 24 bit integer <code>n</code> to <code>buf</code>, stored in i32.",0,[[["i32",15]]]],[11,"write_i32","","Writes a signed 32 bit integer <code>n</code> to <code>buf</code>.",0,[[["i32",15]]]],[11,"write_i48","","Writes a signed 48 bit integer <code>n</code> to <code>buf</code>, stored in i64.",0,[[["i64",15]]]],[11,"write_i64","","Writes a signed 64 bit integer <code>n</code> to <code>buf</code>.",0,[[["i64",15]]]],[11,"write_i128","","Writes a signed 128 bit integer <code>n</code> to <code>buf</code>.",0,[[["i128",15]]]],[11,"write_int","","Writes a signed integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["i64",15],["usize",15]]]],[11,"write_int128","","Writes a signed integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["usize",15],["i128",15]]]],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating …",0,[[["f32",15]]]],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating …",0,[[["f64",15]]]],[10,"read_u16_into","","Reads unsigned 16 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"read_u32_into","","Reads unsigned 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"read_u64_into","","Reads unsigned 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"read_u128_into","","Reads unsigned 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_i16_into","","Reads signed 16 bit integers from <code>src</code> to <code>dst</code>.",0,[[]]],[11,"read_i32_into","","Reads signed 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_i64_into","","Reads signed 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_i128_into","","Reads signed 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_f32_into","","Reads IEEE754 single-precision (4 bytes) floating point …",0,[[]]],[11,"read_f32_into_unchecked","","<strong>DEPRECATED</strong>.",0,[[]]],[11,"read_f64_into","","Reads IEEE754 single-precision (4 bytes) floating point …",0,[[]]],[11,"read_f64_into_unchecked","","<strong>DEPRECATED</strong>.",0,[[]]],[10,"write_u16_into","","Writes unsigned 16 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"write_u32_into","","Writes unsigned 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"write_u64_into","","Writes unsigned 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"write_u128_into","","Writes unsigned 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i8_into","","Writes signed 8 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i16_into","","Writes signed 16 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i32_into","","Writes signed 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i64_into","","Writes signed 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i128_into","","Writes signed 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_f32_into","","Writes IEEE754 single-precision (4 bytes) floating point …",0,[[]]],[11,"write_f64_into","","Writes IEEE754 double-precision (8 bytes) floating point …",0,[[]]],[10,"from_slice_u16","","Converts the given slice of unsigned 16 bit integers to a …",0,[[]]],[10,"from_slice_u32","","Converts the given slice of unsigned 32 bit integers to a …",0,[[]]],[10,"from_slice_u64","","Converts the given slice of unsigned 64 bit integers to a …",0,[[]]],[10,"from_slice_u128","","Converts the given slice of unsigned 128 bit integers to …",0,[[]]],[11,"from_slice_i16","","Converts the given slice of signed 16 bit integers to a …",0,[[]]],[11,"from_slice_i32","","Converts the given slice of signed 32 bit integers to a …",0,[[]]],[11,"from_slice_i64","","Converts the given slice of signed 64 bit integers to a …",0,[[]]],[11,"from_slice_i128","","Converts the given slice of signed 128 bit integers to a …",0,[[]]],[10,"from_slice_f32","","Converts the given slice of IEEE754 single-precision (4 …",0,[[]]],[10,"from_slice_f64","","Converts the given slice of IEEE754 double-precision (8 …",0,[[]]],[4,"BigEndian","","Defines big-endian serialization.",null,null],[6,"BE","","A type alias for <code>BigEndian</code>.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"LE","","A type alias for <code>LittleEndian</code>.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"read_u16","","",1,[[],["u16",15]]],[11,"read_u32","","",1,[[],["u32",15]]],[11,"read_u64","","",1,[[],["u64",15]]],[11,"read_u128","","",1,[[],["u128",15]]],[11,"read_uint","","",1,[[["usize",15]],["u64",15]]],[11,"read_uint128","","",1,[[["usize",15]],["u128",15]]],[11,"write_u16","","",1,[[["u16",15]]]],[11,"write_u32","","",1,[[["u32",15]]]],[11,"write_u64","","",1,[[["u64",15]]]],[11,"write_u128","","",1,[[["u128",15]]]],[11,"write_uint","","",1,[[["usize",15],["u64",15]]]],[11,"write_uint128","","",1,[[["usize",15],["u128",15]]]],[11,"read_u16_into","","",1,[[]]],[11,"read_u32_into","","",1,[[]]],[11,"read_u64_into","","",1,[[]]],[11,"read_u128_into","","",1,[[]]],[11,"write_u16_into","","",1,[[]]],[11,"write_u32_into","","",1,[[]]],[11,"write_u64_into","","",1,[[]]],[11,"write_u128_into","","",1,[[]]],[11,"from_slice_u16","","",1,[[]]],[11,"from_slice_u32","","",1,[[]]],[11,"from_slice_u64","","",1,[[]]],[11,"from_slice_u128","","",1,[[]]],[11,"from_slice_f32","","",1,[[]]],[11,"from_slice_f64","","",1,[[]]],[11,"read_u16","","",2,[[],["u16",15]]],[11,"read_u32","","",2,[[],["u32",15]]],[11,"read_u64","","",2,[[],["u64",15]]],[11,"read_u128","","",2,[[],["u128",15]]],[11,"read_uint","","",2,[[["usize",15]],["u64",15]]],[11,"read_uint128","","",2,[[["usize",15]],["u128",15]]],[11,"write_u16","","",2,[[["u16",15]]]],[11,"write_u32","","",2,[[["u32",15]]]],[11,"write_u64","","",2,[[["u64",15]]]],[11,"write_u128","","",2,[[["u128",15]]]],[11,"write_uint","","",2,[[["usize",15],["u64",15]]]],[11,"write_uint128","","",2,[[["usize",15],["u128",15]]]],[11,"read_u16_into","","",2,[[]]],[11,"read_u32_into","","",2,[[]]],[11,"read_u64_into","","",2,[[]]],[11,"read_u128_into","","",2,[[]]],[11,"write_u16_into","","",2,[[]]],[11,"write_u32_into","","",2,[[]]],[11,"write_u64_into","","",2,[[]]],[11,"write_u128_into","","",2,[[]]],[11,"from_slice_u16","","",2,[[]]],[11,"from_slice_u32","","",2,[[]]],[11,"from_slice_u64","","",2,[[]]],[11,"from_slice_u128","","",2,[[]]],[11,"from_slice_f32","","",2,[[]]],[11,"from_slice_f64","","",2,[[]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"eq","","",1,[[["bigendian",4]],["bool",15]]],[11,"eq","","",2,[[["littleendian",4]],["bool",15]]],[11,"cmp","","",1,[[["bigendian",4]],["ordering",4]]],[11,"cmp","","",2,[[["littleendian",4]],["ordering",4]]],[11,"partial_cmp","","",1,[[["bigendian",4]],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",2,[[["littleendian",4]],[["ordering",4],["option",4]]]],[11,"hash","","",1,[[]]],[11,"hash","","",2,[[]]],[11,"clone","","",1,[[],["bigendian",4]]],[11,"clone","","",2,[[],["littleendian",4]]],[11,"default","","",1,[[],["bigendian",4]]],[11,"default","","",2,[[],["littleendian",4]]]],"p":[[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]},\
"hash32":{"doc":"32-bit hashing machinery","i":[[3,"FnvHasher","hash32","32-bit Fowler-Noll-Vo hasher",null,null],[3,"Murmur3Hasher","","32-bit MurmurHash3 hasher",null,null],[3,"BuildHasherDefault","","See <code>core::hash::BuildHasherDefault</code> for details",null,null],[11,"new","","<code>const</code> constructor",0,[[]]],[8,"BuildHasher","","See <code>core::hash::BuildHasher</code> for details",null,null],[16,"Hasher","","See <code>core::hash::BuildHasher::Hasher</code>",1,null],[10,"build_hasher","","See <code>core::hash::BuildHasher.build_hasher</code>",1,[[]]],[8,"Hasher","","See <code>core::hash::Hasher</code> for details",null,null],[10,"finish","","See <code>core::hash::Hasher.finish</code>",2,[[],["u32",15]]],[10,"write","","See <code>core::hash::Hasher.write</code>",2,[[]]],[8,"Hash","","See <code>core::hash::Hash</code> for details",null,null],[10,"hash","","Feeds this value into the given <code>Hasher</code>.",3,[[]]],[11,"hash_slice","","Feeds a slice of this type into the given <code>Hasher</code>.",3,[[]]],[11,"from","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"build_hasher","","",0,[[]]],[11,"finish","","",4,[[],["u32",15]]],[11,"write","","",4,[[]]],[11,"finish","","",5,[[],["u32",15]]],[11,"write","","",5,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[["buildhasherdefault",3]],["bool",15]]],[11,"clone","","",0,[[]]],[11,"default","","",4,[[]]],[11,"default","","",5,[[]]],[11,"default","","",0,[[]]]],"p":[[3,"BuildHasherDefault"],[8,"BuildHasher"],[8,"Hasher"],[8,"Hash"],[3,"FnvHasher"],[3,"Murmur3Hasher"]]},\
"heapless":{"doc":"<code>static</code> friendly data structures that don\'t require …","i":[[0,"binary_heap","heapless","A priority queue implemented with a binary heap.",null,null],[4,"Min","heapless::binary_heap","Min-heap",null,null],[4,"Max","","Max-heap",null,null],[3,"BinaryHeap","","A priority queue implemented with a binary heap.",null,null],[11,"new","","Creates an empty BinaryHeap as a $K-heap.",0,[[]]],[11,"capacity","","Returns the capacity of the binary heap.",0,[[],["usize",15]]],[11,"clear","","Drops all items from the binary heap.",0,[[]]],[11,"len","","Returns the length of the binary heap.",0,[[],["usize",15]]],[11,"is_empty","","Checks if the binary heap is empty.",0,[[],["bool",15]]],[11,"iter","","Returns an iterator visiting all values in the underlying …",0,[[],["iter",3]]],[11,"iter_mut","","Returns a mutable iterator visiting all values in the …",0,[[],["itermut",3]]],[11,"peek","","Returns the <em>top</em> (greatest if max-heap, smallest if …",0,[[],["option",4]]],[11,"peek_mut","","Returns a mutable reference to the greatest item in the …",0,[[],[["peekmut",3],["option",4]]]],[11,"pop","","Removes the <em>top</em> (greatest if max-heap, smallest if …",0,[[],["option",4]]],[11,"pop_unchecked","","Removes the <em>top</em> (greatest if max-heap, smallest if …",0,[[]]],[11,"push","","Pushes an item onto the binary heap.",0,[[],["result",4]]],[11,"push_unchecked","","Pushes an item onto the binary heap without first …",0,[[]]],[3,"PeekMut","","Structure wrapping a mutable reference to the greatest …",null,null],[11,"pop","","Removes the peeked value from the heap and returns it.",1,[[["peekmut",3]]]],[0,"mpmc","heapless","A fixed capacity Multiple-Producer Multiple-Consumer …",null,null],[3,"Q2","heapless::mpmc","MPMC queue with a capacity for 2 elements",null,null],[11,"new","","Creates an empty queue",2,[[]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",2,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",2,[[],["result",4]]],[3,"Q4","","MPMC queue with a capacity for 4 elements",null,null],[11,"new","","Creates an empty queue",3,[[]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",3,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",3,[[],["result",4]]],[3,"Q8","","MPMC queue with a capacity for 8 elements",null,null],[11,"new","","Creates an empty queue",4,[[]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",4,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",4,[[],["result",4]]],[3,"Q16","","MPMC queue with a capacity for 16 elements",null,null],[11,"new","","Creates an empty queue",5,[[]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",5,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",5,[[],["result",4]]],[3,"Q32","","MPMC queue with a capacity for 32 elements",null,null],[11,"new","","Creates an empty queue",6,[[]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",6,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",6,[[],["result",4]]],[3,"Q64","","MPMC queue with a capacity for 64 elements",null,null],[11,"new","","Creates an empty queue",7,[[]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",7,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",7,[[],["result",4]]],[0,"pool","heapless","A heap-less, interrupt-safe, lock-free memory pool (*)",null,null],[0,"singleton","heapless::pool","<code>Pool</code> as a global singleton",null,null],[8,"Pool","heapless::pool::singleton","A global singleton memory pool",null,null],[16,"Data","","The type of data that can be allocated on this pool",8,null],[11,"alloc","","Claims a memory block from the pool",8,[[],[["box",3],["option",4]]]],[11,"grow","","Increases the capacity of the pool",8,[[],["usize",15]]],[11,"grow_exact","","Increases the capacity of the pool",8,[[["maybeuninit",19]],["usize",15]]],[3,"Box","","A memory block that belongs to the global memory pool, …",null,null],[11,"init","","Initializes this memory block",9,[[],[["init",4],["box",3]]]],[11,"freeze","","Freezes the contents of this memory block",9,[[],[["init",4],["box",3]]]],[11,"forget","","Forgets the contents of this memory block without running …",9,[[],[["uninit",4],["box",3]]]],[3,"Node","heapless::pool","Unfortunate implementation detail required to use the …",null,null],[3,"Pool","","A lock-free memory pool",null,null],[11,"new","","Creates a new empty pool",10,[[]]],[11,"alloc","","Claims a memory block from the pool",10,[[],[["box",3],["option",4]]]],[11,"free","","Returns a memory block to the pool",10,[[["box",3]]]],[11,"grow","","Increases the capacity of the pool",10,[[],["usize",15]]],[11,"grow_exact","","Increases the capacity of the pool",10,[[["maybeuninit",19]],["usize",15]]],[3,"Box","","A memory block",null,null],[11,"init","","Initializes this memory block",11,[[],[["init",4],["box",3]]]],[4,"Uninit","","Uninitialized type state",null,null],[4,"Init","","Initialized type state",null,null],[0,"spsc","heapless","Fixed capacity Single Producer Single Consumer (SPSC) …",null,null],[3,"Queue","heapless::spsc","A statically allocated single producer single consumer …",null,null],[11,"new","","Creates an empty queue with a fixed capacity of <code>N - 1</code>",12,[[]]],[11,"capacity","","Returns the maximum number of elements the queue can hold",12,[[],["usize",15]]],[11,"len","","Returns the number of elements in the queue",12,[[],["usize",15]]],[11,"is_empty","","Returns <code>true</code> if the queue is empty",12,[[],["bool",15]]],[11,"is_full","","Returns <code>true</code> if the queue is full",12,[[],["bool",15]]],[11,"iter","","Iterates from the front of the queue to the back",12,[[],["iter",3]]],[11,"iter_mut","","Returns an iterator that allows modifying each value",12,[[],["itermut",3]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",12,[[],["result",4]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",12,[[],["option",4]]],[11,"peek","","Returns a reference to the item in the front of the queue …",12,[[],["option",4]]],[11,"enqueue_unchecked","","Adds an <code>item</code> to the end of the queue, without checking if …",12,[[]]],[11,"dequeue_unchecked","","Returns the item in the front of the queue, without …",12,[[]]],[11,"split","","Splits a queue into producer and consumer endpoints",12,[[]]],[3,"Iter","","An iterator over the items of a queue",null,null],[3,"IterMut","","A mutable iterator over the items of a queue",null,null],[3,"Consumer","","A queue \\\"consumer\\\"; it can dequeue items from the queue …",null,null],[3,"Producer","","A queue \\\"producer\\\"; it can enqueue items into the queue …",null,null],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",13,[[],["option",4]]],[11,"dequeue_unchecked","","Returns the item in the front of the queue, without …",13,[[]]],[11,"ready","","Returns if there are any items to dequeue. When this …",13,[[],["bool",15]]],[11,"len","","Returns the number of elements in the queue",13,[[],["usize",15]]],[11,"capacity","","Returns the maximum number of elements the queue can hold",13,[[],["usize",15]]],[11,"peek","","Returns the item in the front of the queue without …",13,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue, returns back the …",14,[[],["result",4]]],[11,"enqueue_unchecked","","Adds an <code>item</code> to the end of the queue, without checking if …",14,[[]]],[11,"ready","","Returns if there is any space to enqueue a new item. When …",14,[[],["bool",15]]],[11,"len","","Returns the number of elements in the queue",14,[[],["usize",15]]],[11,"capacity","","Returns the maximum number of elements the queue can hold",14,[[],["usize",15]]],[3,"HistoryBuffer","heapless","A \\\"history buffer\\\", similar to a write-only ring buffer …",null,null],[6,"FnvIndexMap","","A <code>heapless::IndexMap</code> using the default FNV hasher",null,null],[3,"IndexMap","","Fixed capacity <code>IndexMap</code>",null,null],[6,"FnvIndexSet","","A <code>heapless::IndexSet</code> using the default FNV hasher. A list …",null,null],[3,"IndexSet","","Fixed capacity <code>IndexSet</code>.",null,null],[3,"LinearMap","","A fixed capacity map / dictionary that performs lookups …",null,null],[3,"String","","A fixed capacity <code>String</code>",null,null],[3,"Vec","","A fixed capacity <code>Vec</code>",null,null],[11,"from","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"into","","",15,[[]]],[11,"try_into","","",15,[[],["result",4]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from","","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"into","","",16,[[]]],[11,"try_into","","",16,[[],["result",4]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from","","",17,[[]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"into","","",17,[[]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"into","","",18,[[]]],[11,"try_into","","",18,[[],["result",4]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"into","","",19,[[]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"into","","",20,[[]]],[11,"try_into","","",20,[[],["result",4]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","heapless::binary_heap","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"into","","",21,[[]]],[11,"try_into","","",21,[[],["result",4]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","","",22,[[]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"into","","",22,[[]]],[11,"try_into","","",22,[[],["result",4]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","heapless::mpmc","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","heapless::pool::singleton","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","heapless::pool","",23,[[]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"into","","",23,[[]]],[11,"try_into","","",23,[[],["result",4]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","","",24,[[]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"into","","",24,[[]]],[11,"try_into","","",24,[[],["result",4]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","","",25,[[]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"into","","",25,[[]]],[11,"try_into","","",25,[[],["result",4]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","heapless::spsc","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"into","","",26,[[]]],[11,"try_into","","",26,[[],["result",4]]],[11,"into_iter","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","","",27,[[]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"into","","",27,[[]]],[11,"try_into","","",27,[[],["result",4]]],[11,"into_iter","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"into","","",13,[[]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"deref","heapless","",19,[[],["str",15]]],[11,"deref","","",20,[[]]],[11,"deref","heapless::binary_heap","",1,[[]]],[11,"deref","heapless::pool::singleton","",9,[[]]],[11,"deref","heapless::pool","",11,[[]]],[11,"deref_mut","heapless","",19,[[],["str",15]]],[11,"deref_mut","","",20,[[]]],[11,"deref_mut","heapless::binary_heap","",1,[[]]],[11,"deref_mut","heapless::pool::singleton","",9,[[]]],[11,"deref_mut","heapless::pool","",11,[[]]],[11,"from","heapless","",19,[[["str",15]]]],[11,"from","","",19,[[["i8",15]]]],[11,"from","","",19,[[["i16",15]]]],[11,"from","","",19,[[["i32",15]]]],[11,"from","","",19,[[["i64",15]]]],[11,"from","","",19,[[["u8",15]]]],[11,"from","","",19,[[["u16",15]]]],[11,"from","","",19,[[["u32",15]]]],[11,"from","","",19,[[["u64",15]]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::binary_heap","",0,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool::singleton","",9,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool","",11,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::spsc","",12,[[["formatter",3]],["result",6]]],[11,"fmt","heapless","",19,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool::singleton","",9,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool","",11,[[["formatter",3]],["result",6]]],[11,"eq","heapless","",16,[[["indexmap",3]],["bool",15]]],[11,"eq","","",17,[[["indexset",3]],["bool",15]]],[11,"eq","","",18,[[["linearmap",3]],["bool",15]]],[11,"eq","","",19,[[["string",3]],["bool",15]]],[11,"ne","","",19,[[["string",3]],["bool",15]]],[11,"eq","","",19,[[["str",15]],["bool",15]]],[11,"ne","","",19,[[["str",15]],["bool",15]]],[11,"eq","","",19,[[["str",15]],["bool",15]]],[11,"ne","","",19,[[["str",15]],["bool",15]]],[11,"eq","","",20,[[["vec",3]],["bool",15]]],[11,"eq","","",20,[[],["bool",15]]],[11,"eq","","",20,[[],["bool",15]]],[11,"eq","","",20,[[],["bool",15]]],[11,"eq","","",20,[[],["bool",15]]],[11,"eq","","",20,[[],["bool",15]]],[11,"eq","heapless::pool::singleton","",9,[[["box",3]],["bool",15]]],[11,"eq","heapless::pool","",11,[[["box",3]],["bool",15]]],[11,"eq","heapless::spsc","",12,[[["queue",3]],["bool",15]]],[11,"cmp","heapless::pool::singleton","",9,[[["box",3]],["ordering",4]]],[11,"cmp","heapless::pool","",11,[[["box",3]],["ordering",4]]],[11,"partial_cmp","heapless::pool::singleton","",9,[[["box",3]],[["option",4],["ordering",4]]]],[11,"partial_cmp","heapless::pool","",11,[[["box",3]],[["option",4],["ordering",4]]]],[11,"drop","heapless","",15,[[]]],[11,"drop","","",18,[[]]],[11,"drop","","",20,[[]]],[11,"drop","heapless::binary_heap","",1,[[]]],[11,"drop","","",0,[[]]],[11,"drop","heapless::pool::singleton","",9,[[]]],[11,"drop","heapless::spsc","",12,[[]]],[11,"index","heapless","",16,[[]]],[11,"index","","",18,[[]]],[11,"index_mut","","",16,[[]]],[11,"index_mut","","",18,[[]]],[11,"hash","","",19,[[]]],[11,"hash","","",20,[[]]],[11,"hash","heapless::pool::singleton","",9,[[]]],[11,"hash","heapless::pool","",11,[[]]],[11,"hash","heapless::spsc","",12,[[]]],[11,"from_str","heapless","",19,[[["str",15]],["result",4]]],[11,"write_str","","",19,[[["str",15]],[["error",3],["result",4]]]],[11,"write_char","","",19,[[["char",15]],[["error",3],["result",4]]]],[11,"write_str","","",20,[[["str",15]],["result",6]]],[11,"from_iter","","",16,[[]]],[11,"from_iter","","",17,[[]]],[11,"from_iter","","",18,[[]]],[11,"from_iter","","",20,[[]]],[11,"as_ref","","",19,[[],["str",15]]],[11,"as_ref","","",19,[[]]],[11,"as_ref","","",20,[[]]],[11,"as_ref","","",20,[[]]],[11,"as_ref","heapless::pool::singleton","",9,[[]]],[11,"as_ref","heapless::pool","",11,[[]]],[11,"as_mut","heapless","",20,[[]]],[11,"as_mut","","",20,[[]]],[11,"as_mut","heapless::pool::singleton","",9,[[]]],[11,"as_mut","heapless::pool","",11,[[]]],[11,"next_back","heapless::spsc","",26,[[],["option",4]]],[11,"next_back","","",27,[[],["option",4]]],[11,"next","","",26,[[],["option",4]]],[11,"next","","",27,[[],["option",4]]],[11,"into_iter","heapless","",20,[[]]],[11,"extend","","",15,[[]]],[11,"extend","","",15,[[]]],[11,"extend","","",16,[[]]],[11,"extend","","",16,[[]]],[11,"extend","","",17,[[]]],[11,"extend","","",17,[[]]],[11,"extend","","",20,[[]]],[11,"extend","","",20,[[]]],[11,"clone","","",16,[[]]],[11,"clone","","",17,[[]]],[11,"clone","","",18,[[]]],[11,"clone","","",19,[[]]],[11,"clone","","",20,[[]]],[11,"clone","heapless::binary_heap","",0,[[]]],[11,"clone","heapless::spsc","",12,[[]]],[11,"clone","","",26,[[]]],[11,"default","heapless","",16,[[]]],[11,"default","","",17,[[]]],[11,"default","","",18,[[]]],[11,"default","","",19,[[]]],[11,"default","","",20,[[]]],[11,"default","heapless::binary_heap","",0,[[]]],[11,"hash","heapless","",19,[[]]],[11,"hash","","",20,[[]]],[11,"hash","heapless::spsc","",12,[[]]],[11,"new","heapless","Constructs a new history buffer.",15,[[]]],[11,"clear","","Clears the buffer, replacing every element with the …",15,[[]]],[11,"new_with","","Constructs a new history buffer, where every element is …",15,[[]]],[11,"clear_with","","Clears the buffer, replacing every element with the given …",15,[[]]],[11,"len","","Returns the current fill level of the buffer.",15,[[],["usize",15]]],[11,"capacity","","Returns the capacity of the buffer, which is the length …",15,[[],["usize",15]]],[11,"write","","Writes an element to the buffer, overwriting the oldest …",15,[[]]],[11,"extend_from_slice","","Clones and writes all elements in a slice to the buffer.",15,[[]]],[11,"recent","","Returns a reference to the most recently written value.",15,[[],["option",4]]],[11,"as_slice","","Returns the array slice backing the buffer, without …",15,[[]]],[11,"new","","Creates an empty <code>IndexMap</code>.",16,[[]]],[11,"capacity","","Returns the number of elements the map can hold",16,[[],["usize",15]]],[11,"keys","","Return an iterator over the keys of the map, in their …",16,[[]]],[11,"values","","Return an iterator over the values of the map, in their …",16,[[]]],[11,"values_mut","","Return an iterator over mutable references to the the …",16,[[]]],[11,"iter","","Return an iterator over the key-value pairs of the map, …",16,[[],["iter",3]]],[11,"iter_mut","","Return an iterator over the key-value pairs of the map, …",16,[[],["itermut",3]]],[11,"len","","Return the number of key-value pairs in the map.",16,[[],["usize",15]]],[11,"is_empty","","Returns true if the map contains no elements.",16,[[],["bool",15]]],[11,"clear","","Remove all key-value pairs in the map, while preserving …",16,[[]]],[11,"get","","Returns a reference to the value corresponding to the key.",16,[[],["option",4]]],[11,"contains_key","","Returns true if the map contains a value for the …",16,[[],["bool",15]]],[11,"get_mut","","Returns a mutable reference to the value corresponding to …",16,[[],["option",4]]],[11,"insert","","Inserts a key-value pair into the map.",16,[[],[["option",4],["result",4]]]],[11,"remove","","Same as <code>swap_remove</code>",16,[[],["option",4]]],[11,"swap_remove","","Remove the key-value pair equivalent to <code>key</code> and return …",16,[[],["option",4]]],[11,"new","","Creates an empty <code>IndexSet</code>",17,[[]]],[11,"capacity","","Returns the number of elements the set can hold",17,[[],["usize",15]]],[11,"iter","","Return an iterator over the values of the set, in their …",17,[[],["iter",3]]],[11,"difference","","Visits the values representing the difference, i.e. the …",17,[[["indexset",3]],["difference",3]]],[11,"symmetric_difference","","Visits the values representing the symmetric difference, …",17,[[["indexset",3]]]],[11,"intersection","","Visits the values representing the intersection, i.e. the …",17,[[["indexset",3]],["intersection",3]]],[11,"union","","Visits the values representing the union, i.e. all the …",17,[[["indexset",3]]]],[11,"len","","Returns the number of elements in the set.",17,[[],["usize",15]]],[11,"is_empty","","Returns <code>true</code> if the set contains no elements.",17,[[],["bool",15]]],[11,"clear","","Clears the set, removing all values.",17,[[]]],[11,"contains","","Returns <code>true</code> if the set contains a value.",17,[[],["bool",15]]],[11,"is_disjoint","","Returns <code>true</code> if <code>self</code> has no elements in common with <code>other</code>…",17,[[["indexset",3]],["bool",15]]],[11,"is_subset","","Returns <code>true</code> if the set is a subset of another, i.e. <code>other</code>…",17,[[["indexset",3]],["bool",15]]],[11,"is_superset","","Examples",17,[[["indexset",3]],["bool",15]]],[11,"insert","","Adds a value to the set.",17,[[],[["bool",15],["result",4]]]],[11,"remove","","Removes a value from the set. Returns <code>true</code> if the value …",17,[[],["bool",15]]],[11,"new","","Creates an empty <code>LinearMap</code>",18,[[]]],[11,"capacity","","Returns the number of elements that the map can hold",18,[[],["usize",15]]],[11,"clear","","Clears the map, removing all key-value pairs",18,[[]]],[11,"contains_key","","Returns true if the map contains a value for the …",18,[[],["bool",15]]],[11,"get","","Returns a reference to the value corresponding to the key",18,[[],["option",4]]],[11,"get_mut","","Returns a mutable reference to the value corresponding to …",18,[[],["option",4]]],[11,"len","","Returns the number of elements in this map",18,[[],["usize",15]]],[11,"insert","","Inserts a key-value pair into the map.",18,[[],[["option",4],["result",4]]]],[11,"is_empty","","Returns true if the map contains no elements",18,[[],["bool",15]]],[11,"iter","","An iterator visiting all key-value pairs in arbitrary …",18,[[],["iter",3]]],[11,"iter_mut","","An iterator visiting all key-value pairs in arbitrary …",18,[[],["itermut",3]]],[11,"keys","","An iterator visiting all keys in arbitrary order",18,[[]]],[11,"remove","","Removes a key from the map, returning the value at the …",18,[[],["option",4]]],[11,"values","","An iterator visiting all values in arbitrary order",18,[[]]],[11,"values_mut","","An iterator visiting all values mutably in arbitrary order",18,[[]]],[11,"new","","Constructs a new, empty <code>String</code> with a fixed capacity of <code>N</code>",19,[[]]],[11,"into_bytes","","Converts a <code>String</code> into a byte vector.",19,[[],[["vec",3],["u8",15]]]],[11,"as_str","","Extracts a string slice containing the entire string.",19,[[],["str",15]]],[11,"as_mut_str","","Converts a <code>String</code> into a mutable string slice.",19,[[],["str",15]]],[11,"as_mut_vec","","Returns a mutable reference to the contents of this <code>String</code>…",19,[[],["vec",3]]],[11,"push_str","","Appends a given string slice onto the end of this <code>String</code>.",19,[[["str",15]],["result",4]]],[11,"capacity","","Returns the maximum number of elements the String can hold",19,[[],["usize",15]]],[11,"push","","Appends the given <code>char</code> to the end of this <code>String</code>.",19,[[["char",15]],["result",4]]],[11,"truncate","","Shortens this <code>String</code> to the specified length.",19,[[["usize",15]]]],[11,"pop","","Removes the last character from the string buffer and …",19,[[],[["option",4],["char",15]]]],[11,"clear","","Truncates this <code>String</code>, removing all contents.",19,[[]]],[11,"new","","Constructs a new, empty vector with a fixed capacity of <code>N</code>",20,[[]]],[11,"from_slice","","Constructs a new vector with a fixed capacity of <code>N</code> and …",20,[[],["result",4]]],[11,"as_slice","","Extracts a slice containing the entire vector.",20,[[]]],[11,"capacity","","Returns the maximum number of elements the vector can …",20,[[],["usize",15]]],[11,"clear","","Clears the vector, removing all values.",20,[[]]],[11,"extend","","Extends the vec from an iterator.",20,[[]]],[11,"extend_from_slice","","Clones and appends all elements in a slice to the <code>Vec</code>.",20,[[],["result",4]]],[11,"pop","","Removes the last element from a vector and returns it, or …",20,[[],["option",4]]],[11,"push","","Appends an <code>item</code> to the back of the collection",20,[[],["result",4]]],[11,"push_unchecked","","Appends an <code>item</code> to the back of the collection",20,[[]]],[11,"truncate","","Shortens the vector, keeping the first <code>len</code> elements and …",20,[[["usize",15]]]],[11,"resize","","Resizes the Vec in-place so that len is equal to new_len.",20,[[["usize",15]],["result",4]]],[11,"resize_default","","Resizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.",20,[[["usize",15]],["result",4]]],[11,"set_len","","Forces the length of the vector to <code>new_len</code>.",20,[[["usize",15]]]],[11,"swap_remove","","Removes an element from the vector and returns it.",20,[[["usize",15]]]],[11,"swap_remove_unchecked","","Removes an element from the vector and returns it.",20,[[["usize",15]]]],[11,"is_full","","Returns true if the vec is full",20,[[],["bool",15]]],[11,"starts_with","","Returns <code>true</code> if <code>needle</code> is a prefix of the Vec.",20,[[],["bool",15]]],[11,"ends_with","","Returns <code>true</code> if <code>needle</code> is a suffix of the Vec.",20,[[],["bool",15]]]],"p":[[3,"BinaryHeap"],[3,"PeekMut"],[3,"Q2"],[3,"Q4"],[3,"Q8"],[3,"Q16"],[3,"Q32"],[3,"Q64"],[8,"Pool"],[3,"Box"],[3,"Pool"],[3,"Box"],[3,"Queue"],[3,"Consumer"],[3,"Producer"],[3,"HistoryBuffer"],[3,"IndexMap"],[3,"IndexSet"],[3,"LinearMap"],[3,"String"],[3,"Vec"],[4,"Min"],[4,"Max"],[3,"Node"],[4,"Uninit"],[4,"Init"],[3,"Iter"],[3,"IterMut"]]},\
"stable_deref_trait":{"doc":"This module defines an unsafe marker trait, StableDeref, …","i":[[8,"StableDeref","stable_deref_trait","An unsafe marker trait for types that deref to a stable …",null,null],[8,"CloneStableDeref","","An unsafe marker trait for types where clones deref to …",null,null]],"p":[]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);