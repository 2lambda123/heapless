var searchIndex = JSON.parse('{\
"byteorder":{"doc":"This crate provides convenience methods for encoding and …","i":[[8,"ByteOrder","byteorder","<code>ByteOrder</code> describes types that can serialize integers as …",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from <code>buf</code>.",0,[[],["u16",15]]],[11,"read_u24","","Reads an unsigned 24 bit integer from <code>buf</code>, stored in u32.",0,[[],["u32",15]]],[10,"read_u32","","Reads an unsigned 32 bit integer from <code>buf</code>.",0,[[],["u32",15]]],[11,"read_u48","","Reads an unsigned 48 bit integer from <code>buf</code>, stored in u64.",0,[[],["u64",15]]],[10,"read_u64","","Reads an unsigned 64 bit integer from <code>buf</code>.",0,[[],["u64",15]]],[10,"read_u128","","Reads an unsigned 128 bit integer from <code>buf</code>.",0,[[],["u128",15]]],[10,"read_uint","","Reads an unsigned n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["u64",15]]],[10,"read_uint128","","Reads an unsigned n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["u128",15]]],[10,"write_u16","","Writes an unsigned 16 bit integer <code>n</code> to <code>buf</code>.",0,[[["u16",15]]]],[11,"write_u24","","Writes an unsigned 24 bit integer <code>n</code> to <code>buf</code>, stored in u32.",0,[[["u32",15]]]],[10,"write_u32","","Writes an unsigned 32 bit integer <code>n</code> to <code>buf</code>.",0,[[["u32",15]]]],[11,"write_u48","","Writes an unsigned 48 bit integer <code>n</code> to <code>buf</code>, stored in u64.",0,[[["u64",15]]]],[10,"write_u64","","Writes an unsigned 64 bit integer <code>n</code> to <code>buf</code>.",0,[[["u64",15]]]],[10,"write_u128","","Writes an unsigned 128 bit integer <code>n</code> to <code>buf</code>.",0,[[["u128",15]]]],[10,"write_uint","","Writes an unsigned integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["usize",15],["u64",15]]]],[10,"write_uint128","","Writes an unsigned integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["usize",15],["u128",15]]]],[11,"read_i16","","Reads a signed 16 bit integer from <code>buf</code>.",0,[[],["i16",15]]],[11,"read_i24","","Reads a signed 24 bit integer from <code>buf</code>, stored in i32.",0,[[],["i32",15]]],[11,"read_i32","","Reads a signed 32 bit integer from <code>buf</code>.",0,[[],["i32",15]]],[11,"read_i48","","Reads a signed 48 bit integer from <code>buf</code>, stored in i64.",0,[[],["i64",15]]],[11,"read_i64","","Reads a signed 64 bit integer from <code>buf</code>.",0,[[],["i64",15]]],[11,"read_i128","","Reads a signed 128 bit integer from <code>buf</code>.",0,[[],["i128",15]]],[11,"read_int","","Reads a signed n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["i64",15]]],[11,"read_int128","","Reads a signed n-bytes integer from <code>buf</code>.",0,[[["usize",15]],["i128",15]]],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point …",0,[[],["f32",15]]],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point …",0,[[],["f64",15]]],[11,"write_i16","","Writes a signed 16 bit integer <code>n</code> to <code>buf</code>.",0,[[["i16",15]]]],[11,"write_i24","","Writes a signed 24 bit integer <code>n</code> to <code>buf</code>, stored in i32.",0,[[["i32",15]]]],[11,"write_i32","","Writes a signed 32 bit integer <code>n</code> to <code>buf</code>.",0,[[["i32",15]]]],[11,"write_i48","","Writes a signed 48 bit integer <code>n</code> to <code>buf</code>, stored in i64.",0,[[["i64",15]]]],[11,"write_i64","","Writes a signed 64 bit integer <code>n</code> to <code>buf</code>.",0,[[["i64",15]]]],[11,"write_i128","","Writes a signed 128 bit integer <code>n</code> to <code>buf</code>.",0,[[["i128",15]]]],[11,"write_int","","Writes a signed integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["i64",15],["usize",15]]]],[11,"write_int128","","Writes a signed integer <code>n</code> to <code>buf</code> using only <code>nbytes</code>.",0,[[["usize",15],["i128",15]]]],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating …",0,[[["f32",15]]]],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating …",0,[[["f64",15]]]],[10,"read_u16_into","","Reads unsigned 16 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"read_u32_into","","Reads unsigned 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"read_u64_into","","Reads unsigned 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"read_u128_into","","Reads unsigned 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_i16_into","","Reads signed 16 bit integers from <code>src</code> to <code>dst</code>.",0,[[]]],[11,"read_i32_into","","Reads signed 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_i64_into","","Reads signed 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_i128_into","","Reads signed 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"read_f32_into","","Reads IEEE754 single-precision (4 bytes) floating point …",0,[[]]],[11,"read_f32_into_unchecked","","<strong>DEPRECATED</strong>.",0,[[]]],[11,"read_f64_into","","Reads IEEE754 single-precision (4 bytes) floating point …",0,[[]]],[11,"read_f64_into_unchecked","","<strong>DEPRECATED</strong>.",0,[[]]],[10,"write_u16_into","","Writes unsigned 16 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"write_u32_into","","Writes unsigned 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"write_u64_into","","Writes unsigned 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[10,"write_u128_into","","Writes unsigned 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i8_into","","Writes signed 8 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i16_into","","Writes signed 16 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i32_into","","Writes signed 32 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i64_into","","Writes signed 64 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_i128_into","","Writes signed 128 bit integers from <code>src</code> into <code>dst</code>.",0,[[]]],[11,"write_f32_into","","Writes IEEE754 single-precision (4 bytes) floating point …",0,[[]]],[11,"write_f64_into","","Writes IEEE754 double-precision (8 bytes) floating point …",0,[[]]],[10,"from_slice_u16","","Converts the given slice of unsigned 16 bit integers to a …",0,[[]]],[10,"from_slice_u32","","Converts the given slice of unsigned 32 bit integers to a …",0,[[]]],[10,"from_slice_u64","","Converts the given slice of unsigned 64 bit integers to a …",0,[[]]],[10,"from_slice_u128","","Converts the given slice of unsigned 128 bit integers to …",0,[[]]],[11,"from_slice_i16","","Converts the given slice of signed 16 bit integers to a …",0,[[]]],[11,"from_slice_i32","","Converts the given slice of signed 32 bit integers to a …",0,[[]]],[11,"from_slice_i64","","Converts the given slice of signed 64 bit integers to a …",0,[[]]],[11,"from_slice_i128","","Converts the given slice of signed 128 bit integers to a …",0,[[]]],[10,"from_slice_f32","","Converts the given slice of IEEE754 single-precision (4 …",0,[[]]],[10,"from_slice_f64","","Converts the given slice of IEEE754 double-precision (8 …",0,[[]]],[4,"BigEndian","","Defines big-endian serialization.",null,null],[6,"BE","","A type alias for <code>BigEndian</code>.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"LE","","A type alias for <code>LittleEndian</code>.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"read_u16","","",1,[[],["u16",15]]],[11,"read_u32","","",1,[[],["u32",15]]],[11,"read_u64","","",1,[[],["u64",15]]],[11,"read_u128","","",1,[[],["u128",15]]],[11,"read_uint","","",1,[[["usize",15]],["u64",15]]],[11,"read_uint128","","",1,[[["usize",15]],["u128",15]]],[11,"write_u16","","",1,[[["u16",15]]]],[11,"write_u32","","",1,[[["u32",15]]]],[11,"write_u64","","",1,[[["u64",15]]]],[11,"write_u128","","",1,[[["u128",15]]]],[11,"write_uint","","",1,[[["usize",15],["u64",15]]]],[11,"write_uint128","","",1,[[["usize",15],["u128",15]]]],[11,"read_u16_into","","",1,[[]]],[11,"read_u32_into","","",1,[[]]],[11,"read_u64_into","","",1,[[]]],[11,"read_u128_into","","",1,[[]]],[11,"write_u16_into","","",1,[[]]],[11,"write_u32_into","","",1,[[]]],[11,"write_u64_into","","",1,[[]]],[11,"write_u128_into","","",1,[[]]],[11,"from_slice_u16","","",1,[[]]],[11,"from_slice_u32","","",1,[[]]],[11,"from_slice_u64","","",1,[[]]],[11,"from_slice_u128","","",1,[[]]],[11,"from_slice_f32","","",1,[[]]],[11,"from_slice_f64","","",1,[[]]],[11,"read_u16","","",2,[[],["u16",15]]],[11,"read_u32","","",2,[[],["u32",15]]],[11,"read_u64","","",2,[[],["u64",15]]],[11,"read_u128","","",2,[[],["u128",15]]],[11,"read_uint","","",2,[[["usize",15]],["u64",15]]],[11,"read_uint128","","",2,[[["usize",15]],["u128",15]]],[11,"write_u16","","",2,[[["u16",15]]]],[11,"write_u32","","",2,[[["u32",15]]]],[11,"write_u64","","",2,[[["u64",15]]]],[11,"write_u128","","",2,[[["u128",15]]]],[11,"write_uint","","",2,[[["usize",15],["u64",15]]]],[11,"write_uint128","","",2,[[["usize",15],["u128",15]]]],[11,"read_u16_into","","",2,[[]]],[11,"read_u32_into","","",2,[[]]],[11,"read_u64_into","","",2,[[]]],[11,"read_u128_into","","",2,[[]]],[11,"write_u16_into","","",2,[[]]],[11,"write_u32_into","","",2,[[]]],[11,"write_u64_into","","",2,[[]]],[11,"write_u128_into","","",2,[[]]],[11,"from_slice_u16","","",2,[[]]],[11,"from_slice_u32","","",2,[[]]],[11,"from_slice_u64","","",2,[[]]],[11,"from_slice_u128","","",2,[[]]],[11,"from_slice_f32","","",2,[[]]],[11,"from_slice_f64","","",2,[[]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"eq","","",1,[[["bigendian",4]],["bool",15]]],[11,"eq","","",2,[[["littleendian",4]],["bool",15]]],[11,"cmp","","",1,[[["bigendian",4]],["ordering",4]]],[11,"cmp","","",2,[[["littleendian",4]],["ordering",4]]],[11,"partial_cmp","","",1,[[["bigendian",4]],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",2,[[["littleendian",4]],[["ordering",4],["option",4]]]],[11,"hash","","",1,[[]]],[11,"hash","","",2,[[]]],[11,"clone","","",1,[[],["bigendian",4]]],[11,"clone","","",2,[[],["littleendian",4]]],[11,"default","","",1,[[],["bigendian",4]]],[11,"default","","",2,[[],["littleendian",4]]]],"p":[[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]},\
"hash32":{"doc":"32-bit hashing machinery","i":[[3,"FnvHasher","hash32","32-bit Fowler-Noll-Vo hasher",null,null],[3,"Murmur3Hasher","","32-bit MurmurHash3 hasher",null,null],[3,"BuildHasherDefault","","See <code>core::hash::BuildHasherDefault</code> for details",null,null],[11,"new","","<code>const</code> constructor",0,[[]]],[8,"BuildHasher","","See <code>core::hash::BuildHasher</code> for details",null,null],[16,"Hasher","","See <code>core::hash::BuildHasher::Hasher</code>",1,null],[10,"build_hasher","","See <code>core::hash::BuildHasher.build_hasher</code>",1,[[]]],[8,"Hasher","","See <code>core::hash::Hasher</code> for details",null,null],[10,"finish","","See <code>core::hash::Hasher.finish</code>",2,[[],["u32",15]]],[10,"write","","See <code>core::hash::Hasher.write</code>",2,[[]]],[8,"Hash","","See <code>core::hash::Hash</code> for details",null,null],[10,"hash","","Feeds this value into the given <code>Hasher</code>.",3,[[]]],[11,"hash_slice","","Feeds a slice of this type into the given <code>Hasher</code>.",3,[[]]],[11,"from","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"build_hasher","","",0,[[]]],[11,"finish","","",4,[[],["u32",15]]],[11,"write","","",4,[[]]],[11,"finish","","",5,[[],["u32",15]]],[11,"write","","",5,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[["buildhasherdefault",3]],["bool",15]]],[11,"clone","","",0,[[]]],[11,"default","","",4,[[]]],[11,"default","","",5,[[]]],[11,"default","","",0,[[]]]],"p":[[3,"BuildHasherDefault"],[8,"BuildHasher"],[8,"Hasher"],[8,"Hash"],[3,"FnvHasher"],[3,"Murmur3Hasher"]]},\
"heapless":{"doc":"<code>static</code> friendly data structures that don\'t require …","i":[[0,"binary_heap","heapless","A priority queue implemented with a binary heap.",null,null],[4,"Min","heapless::binary_heap","Min-heap",null,null],[4,"Max","","Max-heap",null,null],[3,"BinaryHeap","","A priority queue implemented with a binary heap.",null,null],[11,"new","","Creates an empty BinaryHeap as a $K-heap.",0,[[]]],[11,"capacity","","Returns the capacity of the binary heap.",0,[[],["usize",15]]],[11,"clear","","Drops all items from the binary heap.",0,[[]]],[11,"len","","Returns the length of the binary heap.",0,[[],["usize",15]]],[11,"is_empty","","Checks if the binary heap is empty.",0,[[],["bool",15]]],[11,"iter","","Returns an iterator visiting all values in the underlying …",0,[[],["iter",3]]],[11,"iter_mut","","Returns a mutable iterator visiting all values in the …",0,[[],["itermut",3]]],[11,"peek","","Returns the <em>top</em> (greatest if max-heap, smallest if …",0,[[],["option",4]]],[11,"peek_mut","","Returns a mutable reference to the greatest item in the …",0,[[],[["option",4],["peekmut",3]]]],[11,"pop","","Removes the <em>top</em> (greatest if max-heap, smallest if …",0,[[],["option",4]]],[11,"pop_unchecked","","Removes the <em>top</em> (greatest if max-heap, smallest if …",0,[[]]],[11,"push","","Pushes an item onto the binary heap.",0,[[],["result",4]]],[11,"push_unchecked","","Pushes an item onto the binary heap without first …",0,[[]]],[3,"PeekMut","","Structure wrapping a mutable reference to the greatest …",null,null],[11,"pop","","Removes the peeked value from the heap and returns it.",1,[[["peekmut",3]]]],[0,"mpmc","heapless","A fixed capacity Multiple-Producer Multiple-Consumer …",null,null],[6,"Q2","heapless::mpmc","MPMC queue with a capability for 2 elements.",null,null],[6,"Q4","","MPMC queue with a capability for 4 elements.",null,null],[6,"Q8","","MPMC queue with a capability for 8 elements.",null,null],[6,"Q16","","MPMC queue with a capability for 16 elements.",null,null],[6,"Q32","","MPMC queue with a capability for 32 elements.",null,null],[6,"Q64","","MPMC queue with a capability for 64 elements.",null,null],[3,"MpMcQueue","","MPMC queue with a capacity for N elements The max value …",null,null],[11,"new","","Creates an empty queue",2,[[]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",2,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",2,[[],["result",4]]],[0,"pool","heapless","A heap-less, interrupt-safe, lock-free memory pool (*)",null,null],[0,"singleton","heapless::pool","<code>Pool</code> as a global singleton",null,null],[8,"Pool","heapless::pool::singleton","A global singleton memory pool",null,null],[16,"Data","","The type of data that can be allocated on this pool",3,null],[11,"alloc","","Claims a memory block from the pool",3,[[],[["option",4],["box",3]]]],[11,"grow","","Increases the capacity of the pool",3,[[],["usize",15]]],[11,"grow_exact","","Increases the capacity of the pool",3,[[["maybeuninit",19]],["usize",15]]],[3,"Box","","A memory block that belongs to the global memory pool, …",null,null],[11,"init","","Initializes this memory block",4,[[],[["box",3],["init",4]]]],[11,"freeze","","Freezes the contents of this memory block",4,[[],[["box",3],["init",4]]]],[11,"forget","","Forgets the contents of this memory block without running …",4,[[],[["uninit",4],["box",3]]]],[3,"Node","heapless::pool","Unfortunate implementation detail required to use the …",null,null],[3,"Pool","","A lock-free memory pool",null,null],[11,"new","","Creates a new empty pool",5,[[]]],[11,"alloc","","Claims a memory block from the pool",5,[[],[["option",4],["box",3]]]],[11,"free","","Returns a memory block to the pool",5,[[["box",3]]]],[11,"grow","","Increases the capacity of the pool",5,[[],["usize",15]]],[11,"grow_exact","","Increases the capacity of the pool",5,[[["maybeuninit",19]],["usize",15]]],[3,"Box","","A memory block",null,null],[11,"init","","Initializes this memory block",6,[[],[["box",3],["init",4]]]],[4,"Uninit","","Uninitialized type state",null,null],[4,"Init","","Initialized type state",null,null],[0,"spsc","heapless","Fixed capacity Single Producer Single Consumer (SPSC) …",null,null],[3,"Queue","heapless::spsc","A statically allocated single producer single consumer …",null,null],[11,"new","","Creates an empty queue with a fixed capacity of <code>N - 1</code>",7,[[]]],[11,"capacity","","Returns the maximum number of elements the queue can hold",7,[[],["usize",15]]],[11,"len","","Returns the number of elements in the queue",7,[[],["usize",15]]],[11,"is_empty","","Returns <code>true</code> if the queue is empty",7,[[],["bool",15]]],[11,"is_full","","Returns <code>true</code> if the queue is full",7,[[],["bool",15]]],[11,"iter","","Iterates from the front of the queue to the back",7,[[],["iter",3]]],[11,"iter_mut","","Returns an iterator that allows modifying each value",7,[[],["itermut",3]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue",7,[[],["result",4]]],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",7,[[],["option",4]]],[11,"peek","","Returns a reference to the item in the front of the queue …",7,[[],["option",4]]],[11,"enqueue_unchecked","","Adds an <code>item</code> to the end of the queue, without checking if …",7,[[]]],[11,"dequeue_unchecked","","Returns the item in the front of the queue, without …",7,[[]]],[11,"split","","Splits a queue into producer and consumer endpoints",7,[[]]],[3,"Iter","","An iterator over the items of a queue",null,null],[3,"IterMut","","A mutable iterator over the items of a queue",null,null],[3,"Consumer","","A queue \\\"consumer\\\"; it can dequeue items from the queue …",null,null],[3,"Producer","","A queue \\\"producer\\\"; it can enqueue items into the queue …",null,null],[11,"dequeue","","Returns the item in the front of the queue, or <code>None</code> if …",8,[[],["option",4]]],[11,"dequeue_unchecked","","Returns the item in the front of the queue, without …",8,[[]]],[11,"ready","","Returns if there are any items to dequeue. When this …",8,[[],["bool",15]]],[11,"len","","Returns the number of elements in the queue",8,[[],["usize",15]]],[11,"capacity","","Returns the maximum number of elements the queue can hold",8,[[],["usize",15]]],[11,"peek","","Returns the item in the front of the queue without …",8,[[],["option",4]]],[11,"enqueue","","Adds an <code>item</code> to the end of the queue, returns back the …",9,[[],["result",4]]],[11,"enqueue_unchecked","","Adds an <code>item</code> to the end of the queue, without checking if …",9,[[]]],[11,"ready","","Returns if there is any space to enqueue a new item. When …",9,[[],["bool",15]]],[11,"len","","Returns the number of elements in the queue",9,[[],["usize",15]]],[11,"capacity","","Returns the maximum number of elements the queue can hold",9,[[],["usize",15]]],[3,"HistoryBuffer","heapless","A \\\"history buffer\\\", similar to a write-only ring buffer …",null,null],[6,"FnvIndexMap","","A <code>heapless::IndexMap</code> using the default FNV hasher",null,null],[3,"IndexMap","","Fixed capacity <code>IndexMap</code>",null,null],[6,"FnvIndexSet","","A <code>heapless::IndexSet</code> using the default FNV hasher. A list …",null,null],[3,"IndexSet","","Fixed capacity <code>IndexSet</code>.",null,null],[3,"LinearMap","","A fixed capacity map / dictionary that performs lookups …",null,null],[3,"String","","A fixed capacity <code>String</code>",null,null],[3,"Vec","","A fixed capacity <code>Vec</code>",null,null],[11,"from","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"into","","",13,[[]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"into","","",15,[[]]],[11,"try_into","","",15,[[],["result",4]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from","heapless::binary_heap","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"into","","",16,[[]]],[11,"try_into","","",16,[[],["result",4]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from","","",17,[[]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"into","","",17,[[]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","heapless::mpmc","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","heapless::pool::singleton","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","heapless::pool","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"into","","",18,[[]]],[11,"try_into","","",18,[[],["result",4]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"into","","",19,[[]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"into","","",20,[[]]],[11,"try_into","","",20,[[],["result",4]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","heapless::spsc","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"into","","",21,[[]]],[11,"try_into","","",21,[[],["result",4]]],[11,"into_iter","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","","",22,[[]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"into","","",22,[[]]],[11,"try_into","","",22,[[],["result",4]]],[11,"into_iter","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"deref","heapless","",10,[[]]],[11,"deref","","",14,[[],["str",15]]],[11,"deref","","",15,[[]]],[11,"deref","heapless::binary_heap","",1,[[]]],[11,"deref","heapless::pool::singleton","",4,[[]]],[11,"deref","heapless::pool","",6,[[]]],[11,"deref_mut","heapless","",14,[[],["str",15]]],[11,"deref_mut","","",15,[[]]],[11,"deref_mut","heapless::binary_heap","",1,[[]]],[11,"deref_mut","heapless::pool::singleton","",4,[[]]],[11,"deref_mut","heapless::pool","",6,[[]]],[11,"from","heapless","",14,[[["str",15]]]],[11,"from","","",14,[[["i8",15]]]],[11,"from","","",14,[[["i16",15]]]],[11,"from","","",14,[[["i32",15]]]],[11,"from","","",14,[[["i64",15]]]],[11,"from","","",14,[[["u8",15]]]],[11,"from","","",14,[[["u16",15]]]],[11,"from","","",14,[[["u32",15]]]],[11,"from","","",14,[[["u64",15]]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::binary_heap","",0,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool::singleton","",4,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool","",6,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::spsc","",7,[[["formatter",3]],["result",6]]],[11,"fmt","heapless","",14,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool::singleton","",4,[[["formatter",3]],["result",6]]],[11,"fmt","heapless::pool","",6,[[["formatter",3]],["result",6]]],[11,"eq","heapless","",11,[[["indexmap",3]],["bool",15]]],[11,"eq","","",12,[[["indexset",3]],["bool",15]]],[11,"eq","","",13,[[["linearmap",3]],["bool",15]]],[11,"eq","","",14,[[["string",3]],["bool",15]]],[11,"ne","","",14,[[["string",3]],["bool",15]]],[11,"eq","","",14,[[["str",15]],["bool",15]]],[11,"ne","","",14,[[["str",15]],["bool",15]]],[11,"eq","","",14,[[["str",15]],["bool",15]]],[11,"ne","","",14,[[["str",15]],["bool",15]]],[11,"eq","","",15,[[["vec",3]],["bool",15]]],[11,"eq","","",15,[[],["bool",15]]],[11,"eq","","",15,[[],["bool",15]]],[11,"eq","","",15,[[],["bool",15]]],[11,"eq","","",15,[[],["bool",15]]],[11,"eq","","",15,[[],["bool",15]]],[11,"eq","heapless::pool::singleton","",4,[[["box",3]],["bool",15]]],[11,"eq","heapless::pool","",6,[[["box",3]],["bool",15]]],[11,"eq","heapless::spsc","",7,[[["queue",3]],["bool",15]]],[11,"cmp","heapless::pool::singleton","",4,[[["box",3]],["ordering",4]]],[11,"cmp","heapless::pool","",6,[[["box",3]],["ordering",4]]],[11,"partial_cmp","heapless::pool::singleton","",4,[[["box",3]],[["option",4],["ordering",4]]]],[11,"partial_cmp","heapless::pool","",6,[[["box",3]],[["option",4],["ordering",4]]]],[11,"drop","heapless","",10,[[]]],[11,"drop","","",13,[[]]],[11,"drop","","",15,[[]]],[11,"drop","heapless::binary_heap","",1,[[]]],[11,"drop","","",0,[[]]],[11,"drop","heapless::pool::singleton","",4,[[]]],[11,"drop","heapless::spsc","",7,[[]]],[11,"index","heapless","",11,[[]]],[11,"index","","",13,[[]]],[11,"index_mut","","",11,[[]]],[11,"index_mut","","",13,[[]]],[11,"hash","","",14,[[]]],[11,"hash","","",15,[[]]],[11,"hash","heapless::pool::singleton","",4,[[]]],[11,"hash","heapless::pool","",6,[[]]],[11,"hash","heapless::spsc","",7,[[]]],[11,"from_str","heapless","",14,[[["str",15]],["result",4]]],[11,"write_str","","",14,[[["str",15]],[["error",3],["result",4]]]],[11,"write_char","","",14,[[["char",15]],[["error",3],["result",4]]]],[11,"write_str","","",15,[[["str",15]],["result",6]]],[11,"from_iter","","",11,[[]]],[11,"from_iter","","",12,[[]]],[11,"from_iter","","",13,[[]]],[11,"from_iter","","",15,[[]]],[11,"as_ref","","",10,[[]]],[11,"as_ref","","",14,[[],["str",15]]],[11,"as_ref","","",14,[[]]],[11,"as_ref","","",15,[[]]],[11,"as_ref","","",15,[[]]],[11,"as_ref","heapless::pool::singleton","",4,[[]]],[11,"as_ref","heapless::pool","",6,[[]]],[11,"as_mut","heapless","",15,[[]]],[11,"as_mut","","",15,[[]]],[11,"as_mut","heapless::pool::singleton","",4,[[]]],[11,"as_mut","heapless::pool","",6,[[]]],[11,"next_back","heapless::spsc","",21,[[],["option",4]]],[11,"next_back","","",22,[[],["option",4]]],[11,"next","","",21,[[],["option",4]]],[11,"next","","",22,[[],["option",4]]],[11,"into_iter","heapless","",15,[[]]],[11,"extend","","",10,[[]]],[11,"extend","","",10,[[]]],[11,"extend","","",11,[[]]],[11,"extend","","",11,[[]]],[11,"extend","","",12,[[]]],[11,"extend","","",12,[[]]],[11,"extend","","",15,[[]]],[11,"extend","","",15,[[]]],[11,"clone","","",11,[[]]],[11,"clone","","",12,[[]]],[11,"clone","","",13,[[]]],[11,"clone","","",14,[[]]],[11,"clone","","",15,[[]]],[11,"clone","heapless::binary_heap","",0,[[]]],[11,"clone","heapless::spsc","",7,[[]]],[11,"clone","","",21,[[]]],[11,"default","heapless","",11,[[]]],[11,"default","","",12,[[]]],[11,"default","","",13,[[]]],[11,"default","","",14,[[]]],[11,"default","","",15,[[]]],[11,"default","heapless::binary_heap","",0,[[]]],[11,"hash","heapless","",14,[[]]],[11,"hash","","",15,[[]]],[11,"hash","heapless::spsc","",7,[[]]],[11,"new","heapless","Constructs a new history buffer.",10,[[]]],[11,"clear","","Clears the buffer, replacing every element with the …",10,[[]]],[11,"new_with","","Constructs a new history buffer, where every element is …",10,[[]]],[11,"clear_with","","Clears the buffer, replacing every element with the given …",10,[[]]],[11,"len","","Returns the current fill level of the buffer.",10,[[],["usize",15]]],[11,"capacity","","Returns the capacity of the buffer, which is the length …",10,[[],["usize",15]]],[11,"write","","Writes an element to the buffer, overwriting the oldest …",10,[[]]],[11,"extend_from_slice","","Clones and writes all elements in a slice to the buffer.",10,[[]]],[11,"recent","","Returns a reference to the most recently written value.",10,[[],["option",4]]],[11,"as_slice","","Returns the array slice backing the buffer, without …",10,[[]]],[11,"new","","Creates an empty <code>IndexMap</code>.",11,[[]]],[11,"capacity","","Returns the number of elements the map can hold",11,[[],["usize",15]]],[11,"keys","","Return an iterator over the keys of the map, in their …",11,[[]]],[11,"values","","Return an iterator over the values of the map, in their …",11,[[]]],[11,"values_mut","","Return an iterator over mutable references to the the …",11,[[]]],[11,"iter","","Return an iterator over the key-value pairs of the map, …",11,[[],["iter",3]]],[11,"iter_mut","","Return an iterator over the key-value pairs of the map, …",11,[[],["itermut",3]]],[11,"len","","Return the number of key-value pairs in the map.",11,[[],["usize",15]]],[11,"is_empty","","Returns true if the map contains no elements.",11,[[],["bool",15]]],[11,"clear","","Remove all key-value pairs in the map, while preserving …",11,[[]]],[11,"get","","Returns a reference to the value corresponding to the key.",11,[[],["option",4]]],[11,"contains_key","","Returns true if the map contains a value for the …",11,[[],["bool",15]]],[11,"get_mut","","Returns a mutable reference to the value corresponding to …",11,[[],["option",4]]],[11,"insert","","Inserts a key-value pair into the map.",11,[[],[["result",4],["option",4]]]],[11,"remove","","Same as <code>swap_remove</code>",11,[[],["option",4]]],[11,"swap_remove","","Remove the key-value pair equivalent to <code>key</code> and return …",11,[[],["option",4]]],[11,"new","","Creates an empty <code>IndexSet</code>",12,[[]]],[11,"capacity","","Returns the number of elements the set can hold",12,[[],["usize",15]]],[11,"iter","","Return an iterator over the values of the set, in their …",12,[[],["iter",3]]],[11,"difference","","Visits the values representing the difference, i.e. the …",12,[[["indexset",3]],["difference",3]]],[11,"symmetric_difference","","Visits the values representing the symmetric difference, …",12,[[["indexset",3]]]],[11,"intersection","","Visits the values representing the intersection, i.e. the …",12,[[["indexset",3]],["intersection",3]]],[11,"union","","Visits the values representing the union, i.e. all the …",12,[[["indexset",3]]]],[11,"len","","Returns the number of elements in the set.",12,[[],["usize",15]]],[11,"is_empty","","Returns <code>true</code> if the set contains no elements.",12,[[],["bool",15]]],[11,"clear","","Clears the set, removing all values.",12,[[]]],[11,"contains","","Returns <code>true</code> if the set contains a value.",12,[[],["bool",15]]],[11,"is_disjoint","","Returns <code>true</code> if <code>self</code> has no elements in common with <code>other</code>…",12,[[["indexset",3]],["bool",15]]],[11,"is_subset","","Returns <code>true</code> if the set is a subset of another, i.e. <code>other</code>…",12,[[["indexset",3]],["bool",15]]],[11,"is_superset","","Examples",12,[[["indexset",3]],["bool",15]]],[11,"insert","","Adds a value to the set.",12,[[],[["bool",15],["result",4]]]],[11,"remove","","Removes a value from the set. Returns <code>true</code> if the value …",12,[[],["bool",15]]],[11,"new","","Creates an empty <code>LinearMap</code>",13,[[]]],[11,"capacity","","Returns the number of elements that the map can hold",13,[[],["usize",15]]],[11,"clear","","Clears the map, removing all key-value pairs",13,[[]]],[11,"contains_key","","Returns true if the map contains a value for the …",13,[[],["bool",15]]],[11,"get","","Returns a reference to the value corresponding to the key",13,[[],["option",4]]],[11,"get_mut","","Returns a mutable reference to the value corresponding to …",13,[[],["option",4]]],[11,"len","","Returns the number of elements in this map",13,[[],["usize",15]]],[11,"insert","","Inserts a key-value pair into the map.",13,[[],[["result",4],["option",4]]]],[11,"is_empty","","Returns true if the map contains no elements",13,[[],["bool",15]]],[11,"iter","","An iterator visiting all key-value pairs in arbitrary …",13,[[],["iter",3]]],[11,"iter_mut","","An iterator visiting all key-value pairs in arbitrary …",13,[[],["itermut",3]]],[11,"keys","","An iterator visiting all keys in arbitrary order",13,[[]]],[11,"remove","","Removes a key from the map, returning the value at the …",13,[[],["option",4]]],[11,"values","","An iterator visiting all values in arbitrary order",13,[[]]],[11,"values_mut","","An iterator visiting all values mutably in arbitrary order",13,[[]]],[11,"new","","Constructs a new, empty <code>String</code> with a fixed capacity of <code>N</code>",14,[[]]],[11,"into_bytes","","Converts a <code>String</code> into a byte vector.",14,[[],[["vec",3],["u8",15]]]],[11,"as_str","","Extracts a string slice containing the entire string.",14,[[],["str",15]]],[11,"as_mut_str","","Converts a <code>String</code> into a mutable string slice.",14,[[],["str",15]]],[11,"as_mut_vec","","Returns a mutable reference to the contents of this <code>String</code>…",14,[[],["vec",3]]],[11,"push_str","","Appends a given string slice onto the end of this <code>String</code>.",14,[[["str",15]],["result",4]]],[11,"capacity","","Returns the maximum number of elements the String can hold",14,[[],["usize",15]]],[11,"push","","Appends the given <code>char</code> to the end of this <code>String</code>.",14,[[["char",15]],["result",4]]],[11,"truncate","","Shortens this <code>String</code> to the specified length.",14,[[["usize",15]]]],[11,"pop","","Removes the last character from the string buffer and …",14,[[],[["option",4],["char",15]]]],[11,"clear","","Truncates this <code>String</code>, removing all contents.",14,[[]]],[11,"new","","Constructs a new, empty vector with a fixed capacity of <code>N</code>",15,[[]]],[11,"from_slice","","Constructs a new vector with a fixed capacity of <code>N</code> and …",15,[[],["result",4]]],[11,"as_slice","","Extracts a slice containing the entire vector.",15,[[]]],[11,"capacity","","Returns the maximum number of elements the vector can …",15,[[],["usize",15]]],[11,"clear","","Clears the vector, removing all values.",15,[[]]],[11,"extend","","Extends the vec from an iterator.",15,[[]]],[11,"extend_from_slice","","Clones and appends all elements in a slice to the <code>Vec</code>.",15,[[],["result",4]]],[11,"pop","","Removes the last element from a vector and returns it, or …",15,[[],["option",4]]],[11,"push","","Appends an <code>item</code> to the back of the collection",15,[[],["result",4]]],[11,"push_unchecked","","Appends an <code>item</code> to the back of the collection",15,[[]]],[11,"truncate","","Shortens the vector, keeping the first <code>len</code> elements and …",15,[[["usize",15]]]],[11,"resize","","Resizes the Vec in-place so that len is equal to new_len.",15,[[["usize",15]],["result",4]]],[11,"resize_default","","Resizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.",15,[[["usize",15]],["result",4]]],[11,"set_len","","Forces the length of the vector to <code>new_len</code>.",15,[[["usize",15]]]],[11,"swap_remove","","Removes an element from the vector and returns it.",15,[[["usize",15]]]],[11,"swap_remove_unchecked","","Removes an element from the vector and returns it.",15,[[["usize",15]]]],[11,"is_full","","Returns true if the vec is full",15,[[],["bool",15]]],[11,"starts_with","","Returns <code>true</code> if <code>needle</code> is a prefix of the Vec.",15,[[],["bool",15]]],[11,"ends_with","","Returns <code>true</code> if <code>needle</code> is a suffix of the Vec.",15,[[],["bool",15]]]],"p":[[3,"BinaryHeap"],[3,"PeekMut"],[3,"MpMcQueue"],[8,"Pool"],[3,"Box"],[3,"Pool"],[3,"Box"],[3,"Queue"],[3,"Consumer"],[3,"Producer"],[3,"HistoryBuffer"],[3,"IndexMap"],[3,"IndexSet"],[3,"LinearMap"],[3,"String"],[3,"Vec"],[4,"Min"],[4,"Max"],[3,"Node"],[4,"Uninit"],[4,"Init"],[3,"Iter"],[3,"IterMut"]]},\
"stable_deref_trait":{"doc":"This module defines an unsafe marker trait, StableDeref, …","i":[[8,"StableDeref","stable_deref_trait","An unsafe marker trait for types that deref to a stable …",null,null],[8,"CloneStableDeref","","An unsafe marker trait for types where clones deref to …",null,null]],"p":[]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);